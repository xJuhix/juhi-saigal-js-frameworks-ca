{"version":3,"file":"index.js","sources":["../../node_modules/superstruct/lib/index.es.js","../../src/utils/convertArrayToPathName.ts","../../src/superstruct.ts","../../src/joi.ts","../../src/zod.ts","../../src/yup.ts"],"sourcesContent":["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n  constructor(failure, moreFailures) {\n    const {\n      message,\n      ...rest\n    } = failure;\n    const {\n      path\n    } = failure;\n    let failures;\n    const msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    super(msg);\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n\n    this.failures = () => {\n      if (!failures) {\n        failures = [failure, ...moreFailures];\n      }\n\n      return failures;\n    };\n  }\n\n}\n\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(value) {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nfunction shiftIterator(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nfunction* toFailures(result, context) {\n  if (typeof result === 'string') {\n    yield context.fail({\n      message: result\n    });\n  } else if (result === true) {\n    return;\n  } else if (result === false) {\n    yield context.fail();\n  } else {\n    yield* result;\n  }\n}\n\nfunction assign(...Structs) {\n  const schemas = Structs.map(s => s.schema);\n  const schema = Object.assign({}, ...schemas);\n  return object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator\n  });\n}\n/**\n * Create a struct with dynamic, runtime validation.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nfunction dynamic(fn) {\n  return define('dynamic', (value, ctx) => {\n    return ctx.check(value, fn(value, ctx));\n  });\n}\n/**\n * Create a struct with lazily evaluated validation.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nfunction lazy(fn) {\n  let s;\n  return define('lazy', (value, ctx) => {\n    if (!s) {\n      s = fn();\n    }\n\n    return ctx.check(value, s);\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nfunction omit(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = { ...schema\n  };\n\n  for (const key of keys) {\n    delete subschema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nfunction partial(struct) {\n  const schema = struct instanceof Struct ? { ...struct.schema\n  } : { ...struct\n  };\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nfunction pick(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {};\n\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\n\nfunction any() {\n  return define('any', () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    coercer: value => {\n      return Element && Array.isArray(value) ? value.map(v => Element.coercer(v)) : value;\n    },\n\n    *validator(value, ctx) {\n      if (!Array.isArray(value)) {\n        yield ctx.fail(\"Expected an array value, but received: \" + print(value));\n      } else if (Element) {\n        for (const [i, v] of value.entries()) {\n          yield* ctx.check(v, Element, value, i);\n        }\n      }\n    }\n\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\nfunction boolean() {\n  return define('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nfunction date() {\n  return define('date', value => {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n  });\n}\nfunction enums(values) {\n  const schema = {};\n  const description = values.map(v => print(v)).join();\n\n  for (const key of values) {\n    schema[key] = key;\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator: value => {\n      return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n    }\n  });\n}\n/**\n * Ensure that a value is a function.\n */\n\nfunction func() {\n  return define('func', value => {\n    return typeof value === 'function' || \"Expected a function, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nfunction instance(Class) {\n  return define('instance', value => {\n    return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\n\nfunction integer() {\n  return define('integer', value => {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n  });\n}\nfunction intersection(Structs) {\n  return define('intersection', function* (value, ctx) {\n    for (const S of Structs) {\n      yield* ctx.check(value, S);\n    }\n  });\n}\nfunction literal(constant) {\n  const description = print(constant);\n  return define('literal', value => {\n    return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n  });\n}\nfunction map(Key, Value) {\n  return define('map', function* (value, ctx) {\n    if (!(value instanceof Map)) {\n      yield ctx.fail(\"Expected a `Map` object, but received: \" + print(value));\n    } else if (Key && Value) {\n      for (const [k, v] of value.entries()) {\n        yield* ctx.check(k, Key, value, k);\n        yield* ctx.check(v, Value, value, k);\n      }\n    }\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\n\nfunction never() {\n  return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nfunction nullable(struct) {\n  const {\n    refiner\n  } = struct;\n  return new Struct({ ...struct,\n    validator: (value, ctx) => {\n      return value === null || ctx.check(value, struct);\n    },\n    refiner: function* (value, ctx) {\n      if (value != null) {\n        const c = { ...ctx,\n          struct\n        };\n        yield* toFailures(refiner(value, c), c);\n      }\n    }\n  });\n}\n/**\n * Ensure that a value is a number.\n */\n\nfunction number() {\n  return define('number', value => {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n\n    *validator(value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail(\"Expected an object, but received: \" + print(value));\n      } else if (schema) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          const Value = schema[key];\n          const v = value[key];\n          yield* ctx.check(v, Value, value, key);\n        }\n\n        for (const key of unknowns) {\n          const v = value[key];\n          yield* ctx.check(v, Never, value, key);\n        }\n      }\n    },\n\n    coercer: value => {\n      if (!schema || typeof value !== 'object' || value == null) {\n        return value;\n      }\n\n      const ret = {};\n      const unknowns = new Set(Object.keys(value));\n\n      for (const key of knowns) {\n        unknowns.delete(key);\n        const Value = schema[key];\n        const v = value[key];\n        ret[key] = Value.coercer(v);\n      }\n\n      for (const key of unknowns) {\n        ret[key] = value[key];\n      }\n\n      return ret;\n    }\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nfunction optional(struct) {\n  const {\n    refiner\n  } = struct;\n  return new Struct({ ...struct,\n    validator: (value, ctx) => {\n      return value === undefined || ctx.check(value, struct);\n    },\n    refiner: function* (value, ctx) {\n      if (value != null) {\n        const c = { ...ctx,\n          struct\n        };\n        yield* toFailures(refiner(value, c), c);\n      }\n    }\n  });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nfunction record(Key, Value) {\n  return define('record', function* (value, ctx) {\n    if (typeof value !== 'object' || value == null) {\n      yield ctx.fail(\"Expected an object, but received: \" + print(value));\n    } else {\n      for (const k in value) {\n        const v = value[k];\n        yield* ctx.check(k, Key, value, k);\n        yield* ctx.check(v, Value, value, k);\n      }\n    }\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nfunction regexp() {\n  return define('regexp', value => {\n    return value instanceof RegExp;\n  });\n}\nfunction set(Element) {\n  return define('set', function* (value, ctx) {\n    if (!(value instanceof Set)) {\n      yield ctx.fail(\"Expected a `Set` object, but received: \" + print(value));\n    } else if (Element) {\n      for (const val of value) {\n        yield* ctx.check(val, Element, value, val);\n      }\n    }\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\nfunction string() {\n  return define('string', value => {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\nfunction tuple(Elements) {\n  const Never = never();\n  return define('tuple', function* (value, ctx) {\n    if (!Array.isArray(value)) {\n      yield ctx.fail(\"Expected an array, but received: \" + print(value));\n    } else {\n      for (const [index, Element] of Elements.entries()) {\n        const v = value[index];\n        yield* ctx.check(v, Element, value, index);\n      }\n\n      if (value.length > Elements.length) {\n        const index = Elements.length;\n        const v = value[index];\n        yield* ctx.check(v, Never, value, index);\n      }\n    }\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nfunction type(schema) {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n    validator: function* (value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail(\"Expected an object, but received: \" + print(value));\n      } else {\n        for (const key of keys) {\n          const Value = schema[key];\n          const v = value[key];\n          yield* ctx.check(v, Value, value, key);\n        }\n      }\n    }\n  });\n}\nfunction union(Structs) {\n  const description = Structs.map(s => s.type).join(' | ');\n  return define('union', function* (value, ctx) {\n    const failures = [];\n\n    for (const S of Structs) {\n      const [...array] = ctx.check(value, S);\n\n      if (array.length === 0) {\n        return;\n      } else {\n        failures.push(...array);\n      }\n    }\n\n    yield ctx.fail(\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value));\n    yield* failures;\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nfunction unknown() {\n  return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction coerce(struct, condition, coercer) {\n  const fn = struct.coercer;\n  return new Struct({ ...struct,\n    coercer: value => {\n      if (is(value, condition)) {\n        return fn(coercer(value));\n      } else {\n        return fn(value);\n      }\n    }\n  });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction defaulted(S, fallback, options = {}) {\n  const {\n    strict\n  } = options;\n  return coerce(S, unknown(), x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (x === undefined) {\n      return f;\n    }\n\n    if (!strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x\n      };\n      let changed = false;\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return x;\n  });\n}\n/**\n * Augment a struct to mask its input to only properties defined in the struct.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction masked(struct) {\n  return coerce(struct, unknown(), x => {\n    if (typeof struct.schema !== 'object' || struct.schema == null || typeof x !== 'object' || x == null) {\n      return x;\n    } else {\n      const ret = {};\n\n      for (const key in struct.schema) {\n        if (key in x) {\n          ret[key] = x[key];\n        }\n      }\n\n      return ret;\n    }\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction trimmed(struct) {\n  return coerce(struct, string(), x => x.trim());\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nclass Struct {\n  constructor(props) {\n    this.type = props.type;\n    this.schema = props.schema;\n\n    this.coercer = props.coercer || (value => value);\n\n    this.validator = props.validator || (() => []);\n\n    this.refiner = props.refiner || (() => []);\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n\n  assert(value) {\n    return assert(value, this);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n\n  create(value) {\n    return create(value, this);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n\n  is(value) {\n    return is(value, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n\n  mask(value) {\n    return mask(value, this);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n\n  validate(value, options = {}) {\n    return validate(value, this, options);\n  }\n\n}\n/**\n * Assert that a value passes a `Struct`, throwing if it doesn't.\n */\n\nfunction assert(value, struct) {\n  const result = validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of `Struct` and validate it.\n */\n\nfunction create(value, struct) {\n  const ret = struct.coercer(value);\n  assert(ret, struct);\n  return ret;\n}\n/**\n * Mask a value, returning only the subset of properties defined by a Struct.\n */\n\nfunction mask(value, struct) {\n  const M = masked(struct);\n  const ret = create(value, M);\n  return ret;\n}\n/**\n * Check if a value passes a `Struct`.\n */\n\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a `Struct`, returning an error if invalid.\n */\n\nfunction validate(value, struct, options = {}) {\n  if (options.coerce) {\n    value = struct.coercer(value);\n  }\n\n  const failures = check(value, struct);\n  const failure = shiftIterator(failures);\n\n  if (failure) {\n    const error = new StructError(failure, failures);\n    return [error, undefined];\n  } else {\n    return [undefined, value];\n  }\n}\n/**\n * Check a value against a `Struct`, returning an iterable of failures.\n */\n\nfunction* check(value, struct, path = [], branch = []) {\n  const ctx = {\n    value,\n    struct,\n    branch,\n    path,\n\n    check(v, s, parent, key) {\n      const p = parent !== undefined ? [...path, key] : path;\n      const b = parent !== undefined ? [...branch, parent] : branch;\n      return check(v, s, p, b);\n    },\n\n    fail(props = {}) {\n      if (typeof props === 'string') {\n        props = {\n          message: props\n        };\n      }\n\n      const {\n        type\n      } = struct;\n      let {\n        message,\n        refinement\n      } = props;\n\n      if (!message) {\n        message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + (path.length ? \" for `\" + path.join('.') + \"`\" : '') + \", but received: `\" + print(value) + \"`\";\n      }\n\n      return { ...props,\n        value,\n        type,\n        refinement,\n        message,\n        key: path[path.length - 1],\n        path,\n        branch: [...branch, value]\n      };\n    }\n\n  };\n  const failures = toFailures(struct.validator(value, ctx), ctx);\n  const failure = shiftIterator(failures);\n\n  if (failure) {\n    yield failure;\n    yield* failures;\n  } else {\n    yield* toFailures(struct.refiner(value, ctx), ctx);\n  }\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nfunction empty(struct) {\n  const expected = \"Expected an empty \" + struct.type;\n  return refine(struct, 'empty', value => {\n    if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return size === 0 || expected + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return length === 0 || expected + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nfunction max(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'max', value => {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nfunction min(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'min', value => {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', value => {\n    return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + \"/` but received \\\"\" + value + \"\\\"\";\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nfunction size(struct, min, max = min) {\n  const expected = \"Expected a \" + struct.type;\n  const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n  return refine(struct, 'size', value => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n    } else if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nfunction refine(struct, name, refiner) {\n  const fn = struct.refiner;\n  return new Struct({ ...struct,\n\n    *refiner(value, ctx) {\n      yield* toFailures(fn(value, ctx), ctx);\n\n      for (const failure of toFailures(refiner(value, ctx), ctx)) {\n        yield { ...failure,\n          refinement: name\n        };\n      }\n    }\n\n  });\n}\n\nexport { Struct, StructError, any, array, assert, assign, boolean, coerce, create, date, defaulted, define, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, masked, max, min, never, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.es.js.map\n","export default (paths: (string | number)[]): string =>\n  paths\n    .reduce(\n      (previous, path: string | number, index): string =>\n        `${previous}${\n          typeof path === 'string'\n            ? `${index > 0 ? '.' : ''}${path}`\n            : `[${path}]`\n        }`,\n      '',\n    )\n    .toString();\n","import {\n  appendErrors,\n  transformToNestObject,\n  Resolver,\n  ResolverSuccess,\n  ResolverError,\n} from 'react-hook-form';\nimport { StructError, validate, Struct, Infer } from 'superstruct';\nimport convertArrayToPathName from './utils/convertArrayToPathName';\n\nconst parseErrorSchema = (\n  error: StructError,\n  validateAllFieldCriteria: boolean,\n) =>\n  error\n    .failures()\n    .reduce((previous: Record<string, any>, { path, message = '', type }) => {\n      const currentPath = convertArrayToPathName(path);\n      return {\n        ...previous,\n        ...(path\n          ? previous[currentPath] && validateAllFieldCriteria\n            ? {\n                [currentPath]: appendErrors(\n                  currentPath,\n                  validateAllFieldCriteria,\n                  previous,\n                  type || '',\n                  message,\n                ),\n              }\n            : {\n                [currentPath]: previous[currentPath] || {\n                  message,\n                  type,\n                  ...(validateAllFieldCriteria\n                    ? {\n                        types: { [type || '']: message || true },\n                      }\n                    : {}),\n                },\n              }\n          : {}),\n      };\n    }, {});\n\ntype Options = Parameters<typeof validate>[2];\n\nexport const superstructResolver = <T extends Struct<any, any>>(\n  schema: T,\n  options?: Options,\n): Resolver<Infer<T>> => (values, _, validateAllFieldCriteria = false) => {\n  const [errors, result] = validate(values, schema, options);\n\n  if (errors != null) {\n    return {\n      values: {},\n      errors: transformToNestObject(\n        parseErrorSchema(errors, validateAllFieldCriteria),\n      ),\n    } as ResolverError<Infer<T>>;\n  }\n\n  return {\n    values: result,\n    errors: {},\n  } as ResolverSuccess<Infer<T>>;\n};\n","import {\n  appendErrors,\n  transformToNestObject,\n  Resolver,\n  FieldValues,\n} from 'react-hook-form';\nimport * as Joi from 'joi';\nimport convertArrayToPathName from './utils/convertArrayToPathName';\n\nconst parseErrorSchema = (\n  error: Joi.ValidationError,\n  validateAllFieldCriteria: boolean,\n) =>\n  Array.isArray(error.details)\n    ? error.details.reduce(\n        (previous: Record<string, any>, { path, message = '', type }) => {\n          const currentPath = convertArrayToPathName(path);\n\n          return {\n            ...previous,\n            ...(path\n              ? previous[currentPath] && validateAllFieldCriteria\n                ? {\n                    [currentPath]: appendErrors(\n                      currentPath,\n                      validateAllFieldCriteria,\n                      previous,\n                      type,\n                      message,\n                    ),\n                  }\n                : {\n                    [currentPath]: previous[currentPath] || {\n                      message,\n                      type,\n                      ...(validateAllFieldCriteria\n                        ? {\n                            types: { [type]: message || true },\n                          }\n                        : {}),\n                    },\n                  }\n              : {}),\n          };\n        },\n        {},\n      )\n    : [];\n\nexport const joiResolver = <TFieldValues extends FieldValues>(\n  schema: Joi.Schema,\n  options: Joi.AsyncValidationOptions = {\n    abortEarly: false,\n  },\n): Resolver<TFieldValues> => async (\n  values,\n  _,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    return {\n      values: await schema.validateAsync(values, {\n        ...options,\n      }),\n      errors: {},\n    };\n  } catch (e) {\n    return {\n      values: {},\n      errors: transformToNestObject(\n        parseErrorSchema(e, validateAllFieldCriteria),\n      ),\n    };\n  }\n};\n","import {\n  appendErrors,\n  Resolver,\n  ResolverError,\n  ResolverSuccess,\n  transformToNestObject,\n} from 'react-hook-form';\nimport * as z from 'zod';\nimport { ParseParams } from 'zod/lib/src/parser';\nimport convertArrayToPathName from './utils/convertArrayToPathName';\n\nconst parseErrorSchema = (\n  zodError: z.ZodError,\n  validateAllFieldCriteria: boolean,\n) => {\n  if (zodError.isEmpty) {\n    return {};\n  }\n\n  return zodError.errors.reduce<Record<string, any>>(\n    (previous, { path, message, code: type }) => {\n      const currentPath = convertArrayToPathName(path);\n\n      return {\n        ...previous,\n        ...(path\n          ? previous[currentPath] && validateAllFieldCriteria\n            ? {\n                [currentPath]: appendErrors(\n                  currentPath,\n                  validateAllFieldCriteria,\n                  previous,\n                  type,\n                  message,\n                ),\n              }\n            : {\n                [currentPath]: previous[currentPath] || {\n                  message,\n                  type,\n                  ...(validateAllFieldCriteria\n                    ? {\n                        types: { [type]: message || true },\n                      }\n                    : {}),\n                },\n              }\n          : {}),\n      };\n    },\n    {},\n  );\n};\n\nexport const zodResolver = <T extends z.ZodSchema<any, any>>(\n  schema: T,\n  options?: ParseParams,\n): Resolver<z.infer<T>> => async (\n  values,\n  _,\n  validateAllFieldCriteria = false,\n) => {\n  const result = schema.safeParse(values, options);\n\n  if (result.success) {\n    return { values: result.data, errors: {} } as ResolverSuccess<z.infer<T>>;\n  }\n\n  return {\n    values: {},\n    errors: transformToNestObject(\n      parseErrorSchema(result.error, validateAllFieldCriteria),\n    ),\n  } as ResolverError<z.infer<T>>;\n};\n","import { Resolver, transformToNestObject, FieldValues } from 'react-hook-form';\nimport Yup from 'yup';\n\nconst parseErrorSchema = (\n  error: Yup.ValidationError,\n  validateAllFieldCriteria: boolean,\n) =>\n  Array.isArray(error.inner) && error.inner.length\n    ? error.inner.reduce(\n        (previous: Record<string, any>, { path, message, type }) => {\n          const previousTypes = (previous[path] && previous[path].types) || {};\n          const key = path || type;\n\n          return {\n            ...previous,\n            ...(key\n              ? {\n                  [key]: {\n                    ...(previous[key] || {\n                      message,\n                      type,\n                    }),\n                    ...(validateAllFieldCriteria\n                      ? {\n                          types: {\n                            ...previousTypes,\n                            [type]: previousTypes[type]\n                              ? [...[].concat(previousTypes[type]), message]\n                              : message,\n                          },\n                        }\n                      : {}),\n                  },\n                }\n              : {}),\n          };\n        },\n        {},\n      )\n    : {\n        [error.path]: { message: error.message, type: error.type },\n      };\n\nexport const yupResolver = <TFieldValues extends FieldValues>(\n  schema: Yup.ObjectSchema | Yup.Lazy,\n  options: Omit<Yup.ValidateOptions, 'context'> = {\n    abortEarly: false,\n  },\n): Resolver<TFieldValues> => async (\n  values,\n  context,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    if (\n      (options as Yup.ValidateOptions).context &&\n      process.env.NODE_ENV === 'development'\n    ) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"You should not used the yup options context. Please, use the 'useForm' context object instead\",\n      );\n    }\n    return {\n      values: (await schema.validate(values, {\n        ...options,\n        context,\n      })) as any,\n      errors: {},\n    };\n  } catch (e) {\n    const parsedErrors = parseErrorSchema(e, validateAllFieldCriteria);\n    return {\n      values: {},\n      errors: transformToNestObject(parsedErrors),\n    };\n  }\n};\n"],"names":["StructError","TypeError","[object Object]","failure","moreFailures","message","rest","path","failures","super","length","join","Object","assign","this","name","constructor","shiftIterator","input","done","value","next","undefined","toFailures","result","context","fail","validate","struct","options","coerce","coercer","check","branch","ctx","v","s","parent","key","props","type","refinement","JSON","stringify","print","validator","refiner","paths","reduce","previous","index","toString","parseErrorSchema","error","validateAllFieldCriteria","currentPath","convertArrayToPathName","appendErrors","types","Array","isArray","details","zodError","isEmpty","errors","code","schema","abortEarly","async","values","_","validateAsync","e","transformToNestObject","process","env","NODE_ENV","parsedErrors","inner","previousTypes","concat","safeParse","success","data"],"mappings":"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"}